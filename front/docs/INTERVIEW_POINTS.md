# 면접 포인트 정리

## 📋 목차
- [기술 스택 선택 이유](#기술-스택-선택-이유)
- [주요 기능 구현 포인트](#주요-기능-구현-포인트)
- [프로젝트 구조 설명](#프로젝트-구조-설명)
- [성능 최적화](#성능-최적화)
- [에러 처리 및 사용자 경험](#에러-처리-및-사용자-경험)

---

## 기술 스택 선택 이유

### Zustand 사용 이유

**문제 상황:**
- 필터 상태를 홈페이지와 검색 페이지에서 공유해야 함
- 사용자가 선택한 필터 설정을 localStorage에 저장하여 새로고침 후에도 유지 필요
- 필터 변경 시 필요한 컴포넌트만 리렌더링되어야 함

**대안 비교:**
1. **Context API**: Provider로 감싸야 하고, 보일러플레이트가 많음
2. **useState + props**: 여러 페이지에서 상태 공유 어려움
3. **Redux**: 필터 같은 단순한 전역 상태에는 과함
4. **Zustand**: 간단하고 적절한 수준의 복잡도

**선택 이유:**
- ✅ **간결한 API**: Provider 없이 바로 사용 가능
- ✅ **persist 미들웨어**: localStorage 자동 동기화
- ✅ **성능 최적화**: 선택적 구독으로 불필요한 리렌더링 방지
- ✅ **확장성**: 향후 UI 상태, 캐시 관리 등으로 확장 용이
- ✅ **번들 크기**: 약 1KB로 가벼움
- ✅ **TypeScript 지원**: 타입 안정성 확보

**간단한 답변:**
"필터 상태를 여러 페이지에서 공유하고, 사용자 설정을 localStorage에 저장해야 했습니다. Zustand는 persist 미들웨어로 localStorage 동기화가 간단하고, 선택적 구독으로 성능도 좋으며, 코드가 간결해 선택했습니다."

---

## 주요 기능 구현 포인트

### 1. 빈 상태(Empty State) 컴포넌트

**구현 이유:**
- 데이터가 없을 때 빈 화면 대신 사용자 친화적인 UI 제공
- 상황별로 다른 메시지와 액션 버튼 표시

**주요 포인트:**
- 재사용 가능한 컴포넌트로 설계
- 아이콘, 제목, 설명, 액션 버튼을 props로 받아 유연하게 사용
- 홈페이지, 검색 페이지, 마이페이지에서 일관된 UI 제공

**적용 위치:**
- 홈페이지: 프로젝트/경매 없을 때
- 검색 페이지: 검색 결과 없을 때
- 마이페이지: 내역 없을 때

### 2. 필터/정렬 기능

**구현 포인트:**
- Zustand로 전역 상태 관리
- localStorage에 자동 저장 (persist 미들웨어)
- 필터링과 정렬을 분리하여 유지보수성 향상
- useMemo로 성능 최적화

**필터 옵션:**
- 프로젝트: 상태(전체/진행중/성공/실패/취소), 정렬(최신순/인기순/마감임박순/모금액순)
- 경매: 상태(전체/예정/진행중/종료/취소), 정렬(최신순/가격순/마감임박순/입찰수순)

**사용자 경험:**
- 필터 활성화 시 초기화 버튼 표시
- 필터 조건에 맞는 결과가 없을 때 적절한 안내 메시지

### 3. 경매 알림 시스템

**구현 포인트:**
- 찜한 경매가 시작되면 상세 페이지에 있지 않아도 알림 표시
- 현재 보고 있는 경매도 알림 표시
- 중복 알림 방지 (localStorage 사용)
- 재사용 가능한 알림 유틸리티 함수

**기술적 구현:**
- 전역 모니터링 hook (`useWishlistAuctionMonitor`)
- 페이지 가시성 추적 (백그라운드에서는 알림 표시 안 함)
- 동적 체크 주기 (경매 시작 시간에 가까워질수록 더 자주 체크)

### 4. 이미지 관리

**문제 상황:**
- base64 이미지는 localStorage 용량 제한에 걸림
- 페이지 새로고침 시 이미지가 사라지는 문제

**해결 방법:**
- 이미지는 메모리(`imageStore`)에만 저장
- 경매 목록 조회 시 이미지 복원 로직 추가
- 이미지가 없을 때 기본 placeholder 이미지 사용

---

## 프로젝트 구조 설명

### 디렉토리 구조
```
front/
├── app/                    # Next.js App Router 페이지
├── src/
│   ├── components/        # 재사용 가능한 컴포넌트
│   ├── contexts/         # React Context (인증)
│   ├── hooks/            # Custom Hooks
│   ├── lib/              # 유틸리티 함수
│   ├── services/         # API 서비스 (Mock API)
│   ├── stores/           # Zustand 스토어
│   └── types/            # TypeScript 타입 정의
```

### 상태 관리 전략
- **인증**: React Context (기존 코드 유지)
- **필터/정렬**: Zustand (새로 추가)
- **위시리스트**: localStorage 직접 사용
- **로컬 상태**: useState

### 컴포넌트 설계 원칙
- 재사용 가능한 컴포넌트 분리
- UI 컴포넌트와 비즈니스 로직 분리
- Props로 유연하게 사용 가능하도록 설계

---

## 성능 최적화

### 1. useMemo 활용
- 필터링 및 정렬 결과를 useMemo로 메모이제이션
- 의존성 배열을 명확히 하여 불필요한 재계산 방지

### 2. 선택적 구독 (Zustand)
- 필요한 상태만 구독하여 불필요한 리렌더링 방지
- 예: `const { projectStatus } = useFilterStore()` - projectStatus만 구독

### 3. 동적 체크 주기
- 경매 상태 체크 주기를 시간에 따라 동적으로 조정
- 1분 미만: 1초마다, 5분 미만: 2초마다 등

### 4. 이미지 최적화
- base64 이미지는 메모리에만 저장
- localStorage에는 메타데이터만 저장

---

## 에러 처리 및 사용자 경험

### 1. 안전한 데이터 처리
- `bidStep`, `buyoutPrice`가 없을 때 기본값 사용
- 날짜 유효성 검사 (Invalid Date 체크)
- null/undefined 안전 처리

### 2. 로딩 상태
- 데이터 로드 중 로딩 스피너 표시
- 에러 발생 시 사용자 친화적인 메시지

### 3. 빈 상태 처리
- 데이터 없음 vs 필터 조건 불일치 구분
- 상황별 적절한 메시지와 액션 버튼 제공

### 4. 알림 시스템
- 중복 알림 방지
- 페이지 가시성 추적 (백그라운드에서는 알림 안 함)
- 경매 이름 포함한 명확한 알림 메시지

---

## 주요 기술 스택

### 프론트엔드
- **Next.js 16.0.10**: App Router 사용
- **React 19.2.0**: 최신 React 기능 활용
- **TypeScript 5**: 타입 안정성
- **Tailwind CSS**: 유틸리티 기반 스타일링
- **shadcn/ui**: 컴포넌트 라이브러리

### 상태 관리
- **Zustand**: 전역 상태 관리 (필터, 정렬)
- **React Context**: 인증 상태 관리
- **localStorage**: 위시리스트, 필터 설정 저장

### 폼 관리
- **React Hook Form**: 폼 상태 관리
- **Zod**: 스키마 검증

### 기타
- **Sonner**: Toast 알림
- **date-fns**: 날짜 처리
- **lucide-react**: 아이콘

---

## 향후 개선 사항

### 1. 페이지네이션
- 현재는 limit만 있음
- 무한 스크롤 또는 페이지네이션 컴포넌트 추가

### 2. 고급 필터
- 가격대 필터
- 카테고리 필터
- 태그 필터

### 3. 성능 최적화
- 이미지 lazy loading
- 코드 스플리팅
- React.memo 활용

### 4. 접근성
- 키보드 네비게이션
- 스크린 리더 지원
- ARIA 레이블

---

## 면접 예상 질문

### Q1. Zustand를 선택한 이유는?
**답변:** (위의 "Zustand 사용 이유" 참고)

### Q2. Context API 대신 Zustand를 사용한 이유는?
**답변:** 
- Provider 없이 사용 가능하여 코드가 간결함
- persist 미들웨어로 localStorage 동기화가 간단함
- 선택적 구독으로 성능 최적화
- 필터 같은 단순한 전역 상태에는 Context API가 과함

### Q3. 성능 최적화를 위해 어떤 방법을 사용했나요?
**답변:**
- useMemo로 필터링/정렬 결과 메모이제이션
- Zustand의 선택적 구독으로 불필요한 리렌더링 방지
- 동적 체크 주기로 불필요한 API 호출 최소화
- 이미지는 메모리에만 저장하여 localStorage 용량 절약

### Q4. 에러 처리는 어떻게 했나요?
**답변:**
- try-catch로 API 호출 에러 처리
- null/undefined 안전 처리 (옵셔널 체이닝, 기본값 사용)
- 날짜 유효성 검사
- 사용자 친화적인 에러 메시지 표시

### Q5. 빈 상태를 어떻게 처리했나요?
**답변:**
- 재사용 가능한 EmptyState 컴포넌트 생성
- 상황별로 다른 메시지와 액션 버튼 제공
- 데이터 없음 vs 필터 조건 불일치 구분
- 일관된 UI로 사용자 경험 향상

---

## 추가 메모

### 구현하면서 배운 점
- Zustand의 간결함과 강력함
- persist 미들웨어의 편리함
- useMemo를 통한 성능 최적화의 중요성
- 사용자 경험을 고려한 에러 처리의 중요성

### 개선하고 싶은 부분
- 테스트 코드 작성
- Storybook으로 컴포넌트 문서화
- 성능 모니터링 도구 도입
- 접근성 개선

---

**마지막 업데이트**: 2026년 현재
**프로젝트명**: DDIP (크라우드펀딩 & 경매 플랫폼)
